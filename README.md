# aspz-lab12-13

3. Handling Signals

Обробка сигналів включає:
Встановлення обробника сигналу (signal handler), який викликається, коли процес отримує сигнал.
Використання функцій signal() або більш сучасної sigaction().

Код:

![image](https://github.com/user-attachments/assets/914854b5-ac31-4148-a9d9-c6449fe97a53)

Результат:

![image](https://github.com/user-attachments/assets/e7cef290-c419-434e-834e-875911fd058f)

Реалізовано простий обробник сигналу SIGINT через signal(), який перехоплює натискання Ctrl+C та виводить повідомлення замість завершення програми. Показано базове використання обробників сигналів.

4. A Simple C Program that Handles a Couple of Signals
Ця програма:
Виводить свій PID.

Реагує на SIGINT повідомленням.

Завершується при отриманні SIGTERM.

Код:

![image](https://github.com/user-attachments/assets/c19380a3-2acf-40ba-8b46-57f95426cb5e)

Результат:

![image](https://github.com/user-attachments/assets/af61210b-2610-4281-9bcb-61a4bb752266)

Розроблена програма, що обробляє SIGINT (виводить повідомлення) і SIGTERM (коректно завершує процес). Демонструє встановлення кількох обробників сигналів для контролю поведінки процесу.

5. Masking Signals

Іноді потрібно заблокувати (замаскувати) сигнали, щоб тимчасово відкласти їх обробку (наприклад, під час виконання критичної секції коду).

Код:

![image](https://github.com/user-attachments/assets/987dec49-8ee6-4a3b-8600-11e000c346de)

Результат:

![image](https://github.com/user-attachments/assets/d4d89017-53a2-49bc-8a44-5d003236b84b)

Показано, як тимчасово блокувати сигнал (наприклад, SIGINT) за допомогою sigprocmask(). Це дозволяє захистити критичні ділянки коду від переривання сигналом.

6. Reentrant Safety and Signalling
Оскільки обробники сигналів виконуються асинхронно, вони можуть перервати будь-яку функцію. Тому важливо:
Уникати небезпечних (небезпечних для повторного входу) функцій в обробнику сигналів.

Бажано використовувати лише асинхронно-безпечні функції, наприклад: _exit(), write(), signal().

Не можна використовувати: malloc(), printf(), printf() у більшості випадків, fork(), sleep(), strtok() тощо — вони не є thread-safe або reentrant.

Код:

![image](https://github.com/user-attachments/assets/348b3ae2-ac7c-4269-ba05-2efa5deb7d11)

Результат:

![image](https://github.com/user-attachments/assets/37ebe288-52ed-4eb8-8594-abe23e9e8f20)

Обробник сигналу SIGINT реалізовано з використанням тільки асинхронно-безпечної функції write(), яка гарантує безпечне виконання навіть якщо сигнал приходить у довільний момент. Такі функції не використовують буфери або глобальні структури, які могли б бути змінені іншими частинами програми.

7. Sigaction Flags

Функція sigaction() — більш контрольований спосіб установки обробників. Дає змогу:

Встановити маску сигналів під час обробки.

Вказати прапори (flags), що змінюють поведінку.

Код:

![image](https://github.com/user-attachments/assets/eaacf742-fcfb-4553-9942-d3b97171186b)

Результат:

![image](https://github.com/user-attachments/assets/d7ba9968-8d7b-4567-893d-c533f1390856)

Обробник сигналу SIGINT встановлюється через sigaction з прапором SA_RESTART. Програма чекає введення через fgets(). Якщо під час введення натиснути Ctrl+C, то системний виклик не буде перерваний і продовжиться після обробки сигналу.

8. No Zombies
Коли дочірній процес завершується, але батько не викликає wait(), дочірній стає зомбі (process in zombie state).
Щоб уникнути зомбі:
Обробити сигнал SIGCHLD з SA_NOCLDWAIT.
Або викликати waitpid() або wait() у батьківському процесі.

Код:

![image](https://github.com/user-attachments/assets/951cc592-0c31-4308-9412-a09e43ba4ac1)

Результат:

![image](https://github.com/user-attachments/assets/2bab26c9-c5ec-478e-b79f-1eb076a8a31d)

Описано проблему "зомбі"-процесів та способи її уникнення: обробка SIGCHLD з прапором SA_NOCLDWAIT або виклик waitpid() у батька. Наведено приклад ігнорування SIGCHLD для автоматичного збирання дочірніх процесів.

2. Trapping and Extracting Information from a Crash
Обробник сигналу з SA_SIGINFO отримує додаткову інформацію через siginfo_t

Код:

![image](https://github.com/user-attachments/assets/dc1b3cc1-14a1-4618-9d46-96311ac7d17b)

Результат:

![image](https://github.com/user-attachments/assets/6edcf824-6d9b-4d1f-bf04-d445f28019f8)

Результат:

![image](https://github.com/user-attachments/assets/017d22de-5eb2-4eff-ae4d-f7a023f8f713)

У цьому завданні реалізовано програму, яка демонструє, як перехопити помилку сегментації (SIGSEGV) і витягнути інформацію про причину аварії за допомогою сигналів у Linux. Застосовано функцію sigaction() з прапором SA_SIGINFO, що дозволяє отримати додаткові дані про сигнал через структуру siginfo_t. У спеціальному обробнику сигналів виводиться номер сигналу та адреса, за якою стався збій. У тілі програми навмисно викликається сегментаційна помилка шляхом запису значення за адресою NULL. У результаті виконання програма виводить повідомлення на кшталт Caught signal 11 та Fault address: (nil), що свідчить про спробу звернення до недоступної області пам’яті. Такий підхід дозволяє налагоджувати програми без використання зовнішніх інструментів, а також може бути корисним для виявлення причин збоїв у складних системах.

Завдання 17(індивідуальне)

Створіть задачу, в якій через sigaction з SA_RESETHAND можна лише один раз перехопити сигнал — як забезпечити повторний запуск обробника без переоголошення sigaction.

Код:

![image](https://github.com/user-attachments/assets/82527835-ad58-4118-8735-a7da58ce183b)

Результат:

![image](https://github.com/user-attachments/assets/b711212a-187a-49f5-a94a-1569e79d8203)

Програма встановлює обробник сигналу SIGINT за допомогою sigaction з прапором SA_RESETHAND, що дозволяє перехопити сигнал лише один раз. При першому натисканні Ctrl+C спрацьовує обробник, який виводить повідомлення з номером сигналу і лічильником обробок. Після цього обробник автоматично скидається до стандартної поведінки, і при повторному натисканні Ctrl+C програма завершується. Таким чином, обробник спрацьовує лише один раз без необхідності повторно встановлювати sigaction.


